<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Contest Scheduling Visualizer</title>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <style type="text/css">
    textarea {
      font-family: monospace;
    }

    rect {
      shape-rendering: crispEdges;
    }

    text {
      text-anchor: middle;
      dominant-baseline: central;
      font-family: sans-serif;
      font-size: 7px;
      pointer-events: none;
      /* テキスト選択を無効化 */
    }

    .highlight {
      stroke: black !important;
      stroke-width: 2px !important;
    }

    label {
      margin-right: 1em;
      /* ラベル間のスペース */
    }

    input[type=number] {
      width: 70px;
      /* Seed入力欄の幅 */
    }
  </style>
</head>

<body>
  <h1>Contest Scheduling Visualizer</h1>
  <p>
    このページは、<del>gemini</del> <a href="https://thun-c.github.io/" style="color: #804000;">thunder</a>
    によって作られた非公式ビジュアライザです。使用する際は自己責任でお願いします。
  </p>

  <p>
    問題文は <a href="https://atcoder.jp/contests/intro-heuristics/tasks/intro_heuristics_a">こちら</a><br>
    公式解説は <a
      href="https://img.atcoder.jp/intro-heuristics/editorial.pdf?_gl=1*15hcgab*_ga*Njg0MDYzNTgxLjE3MjA4NzI5NDk.*_ga_RC512FD18N*MTc0NDU1NDA4NS4zOTguMS4xNzQ0NTU0NDg0LjAuMC4w">こちら</a><br>
    thunderによる延長戦(提出時点で1位)解説は<a href="https://qiita.com/thun-c/items/fd82d1fb8131746bd347">こちら</a>
  </p>
  <h2>使い方</h2>
  <details open="">
    <p>
      Seed 欄に Seed 番号を入力するか、矢印で値を変更すると、対応するseedの入力が Input 欄に読み込まれます (xxxx は Seed 番号を4桁ゼロ埋めしたもの)。<br>
      または、Input 欄に直接入力データを貼り付けることも可能です。<br>
      Output 欄にあなたのプログラムの出力 (各日のコンテストタイプ t) を貼り付けてください。<br>
      入力または出力が変更されると、ビジュアライザとスコアが自動的に更新されます。（<b>※片方だけでも変更があれば更新されます</b>）<br>
    </p>
    <p>
      ビジュアライザの見方:
    <ul>
      <li>一番上の行は、各コンテストタイプ (1-26) の満足度低下係数 c<sub>i</sub> を示します。値が大きいほど色が赤に近くなります。</li>
      <li>2行目以降は、各日 (1-D) における各コンテストタイプ (1-26) の開催時の満足度増加量 s<sub>d,i</sub> を示します。値が大きいほど色が赤に近くなります。</li>
      <li>各日の行で太枠で囲まれたセルが、その日に開催されたコンテストタイプを示します。</li>
    </ul>
    </p>
  </details>
  <hr>

  <p>
    <label>
      Seed:
      <input type="number" id="seed" value="0" min="0" onchange="loadInputBySeed()">
    </label>
  </p>
  <p>
    <label>
      Input:<br>
      <textarea id="input" rows="10" style="width:800px;" placeholder="Seed を指定してファイルを読み込むか、ここに直接入力データを貼り付けてください。
D
c_1 c_2 ... c_26
s_{1,1} s_{1,2} ... s_{1,26}
...
s_{D,1} s_{D,2} ... s_{D,26}
" oninput="updateVisualization()"></textarea>
    </label>
  </p>
  <p>
    <label>
      Output:<br>
      <textarea id="output" rows="10" style="width:800px;" placeholder="t_1
t_2
...
t_D" oninput="updateVisualization()"></textarea>
    </label>
  </p>
  <hr>
  <p id="score">Score = 0</p>
  <div id="result" style="user-select:none">
    <svg id="vis" width="1060" height="400" viewBox="0 0 1060 400" xmlns="http://www.w3.org/2000/svg">
      <style>
        /* スタイルはヘッダーに移動 */
      </style>
      <!-- SVG content will be generated by JavaScript -->
    </svg>
  </div>
  <br>

  <script>
    const SVG_NS = "http://www.w3.org/2000/svg";
    const CELL_WIDTH = 40;
    const CELL_HEIGHT = 10;
    const HEADER_HEIGHT = 20; // c_i表示用スペース
    const CONTEST_LABEL_HEIGHT = 15; // コンテスト番号表示用スペース
    const DATE_LABEL_WIDTH = 30; // 日付表示用スペース
    const GRID_GAP = 5; // c_iヘッダーとs_{d,i}グリッド間の隙間
    const PADDING = 1;
    const MAX_C = 100; // c_i の最大値
    const MAX_S = 20000; // s_{d,i} の最大値

    function parseInput(inputText) {
      const lines = inputText.trim().split('\n');
      if (lines.length < 2) return null;
      try {
        const D = parseInt(lines[0], 10);
        if (isNaN(D) || D <= 0) return null;
        const c = lines[1].split(/\s+/).map(Number);
        if (c.length !== 26 || c.some(isNaN)) return null;
        if (lines.length < 2 + D) return null;
        const s = [];
        for (let d = 0; d < D; d++) {
          const s_d = lines[2 + d].split(/\s+/).map(Number);
          if (s_d.length !== 26 || s_d.some(isNaN)) return null;
          s.push(s_d);
        }
        return { D, c, s };
      } catch (e) {
        console.error("Input parse error:", e);
        return null;
      }
    }

    function parseOutput(outputText, D) {
      if (!D || D <= 0) return null; // Dが不正ならパースしない
      const lines = outputText.trim().split('\n');
      if (lines.length !== D) return null;
      try {
        const out = lines.map(line => parseInt(line.trim(), 10));
        if (out.some(isNaN) || out.some(t => t < 1 || t > 26)) return null;
        return out;
      } catch (e) {
        console.error("Output parse error:", e);
        return null;
      }
    }

    function calculateScore(D, c, s, out) {
      if (!D || !c || !s || !out || out.length !== D) return 0; // 不正な入力なら0点

      let sat = 0;
      const last = Array(26).fill(0);
      for (let d = 0; d < D; d++) {
        const day = d + 1;
        const contestTypeIndex = out[d] - 1; // 0-indexed

        if (contestTypeIndex < 0 || contestTypeIndex >= 26) {
          console.error(`Invalid contest type ${out[d]} on day ${day}`);
          return 0; // 不正な出力
        }

        last[contestTypeIndex] = day;
        let dailyPenalty = 0;
        for (let i = 0; i < 26; i++) {
          dailyPenalty += (day - last[i]) * c[i];
        }
        sat -= dailyPenalty;
        sat += s[d][contestTypeIndex];
      }
      return Math.max(0, 1000000 + sat);
    }

    // 値に基づいて色を計算 (0に近いほど緑、最大値に近いほど赤)
    function getColor(value, maxValue) {
      if (maxValue <= 0) return "#cccccc"; // Avoid division by zero
      const normalized = Math.max(0, Math.min(1, value / maxValue)); // 0~1に正規化
      // tester.pyのロジックを再現 (緑->黄->赤)
      const h = (1.0 - normalized) * 120 / 360; // Hue (0=赤, 120/360=緑)
      const s = 1.0; // Saturation
      const l = 0.5; // Lightness
      // HSL to RGB conversion (simplified)
      const c = (1 - Math.abs(2 * l - 1)) * s;
      const x = c * (1 - Math.abs((h * 6) % 2 - 1));
      const m = l - c / 2;
      let r = 0, g = 0, b = 0;
      if (0 <= h * 6 && h * 6 < 1) { r = c; g = x; b = 0; }
      else if (1 <= h * 6 && h * 6 < 2) { r = x; g = c; b = 0; }
      else if (2 <= h * 6 && h * 6 < 3) { r = 0; g = c; b = x; }
      else if (3 <= h * 6 && h * 6 < 4) { r = 0; g = x; b = c; }
      else if (4 <= h * 6 && h * 6 < 5) { r = x; g = 0; b = c; }
      else if (5 <= h * 6 && h * 6 < 6) { r = c; g = 0; b = x; }
      r = Math.round((r + m) * 255);
      g = Math.round((g + m) * 255);
      b = Math.round((b + m) * 255);
      return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    function createRect(x, y, width, height, fill, stroke = "grey", strokeWidth = 1) {
      const rect = document.createElementNS(SVG_NS, "rect");
      rect.setAttribute("x", x);
      rect.setAttribute("y", y);
      rect.setAttribute("width", width);
      rect.setAttribute("height", height);
      rect.setAttribute("fill", fill);
      rect.setAttribute("stroke", stroke);
      rect.setAttribute("stroke-width", strokeWidth);
      return rect;
    }

    function createText(x, y, content, fontSize = 7, textAnchor = "middle", dominantBaseline = "central") {
      const text = document.createElementNS(SVG_NS, "text");
      text.setAttribute("x", x);
      text.setAttribute("y", y);
      text.setAttribute("font-size", fontSize + "px");
      text.setAttribute("text-anchor", textAnchor);
      text.setAttribute("dominant-baseline", dominantBaseline);
      text.textContent = content;
      return text;
    }

    function visualize(D, c, s, out) {
      const svg = document.getElementById("vis");
      // Clear previous content
      while (svg.firstChild) {
        svg.removeChild(svg.firstChild);
      }
      // Add style element back
      const style = document.createElementNS(SVG_NS, 'style');
      style.textContent = `
        text { font-family: sans-serif; pointer-events: none; }
        .highlight { stroke: black !important; stroke-width: 2px !important; }
        rect { shape-rendering: crispEdges; }
      `;
      svg.appendChild(style);

      // Calculate total dimensions including new labels and gap
      const gridWidth = 26 * CELL_WIDTH;
      const gridHeight = D ? D * CELL_HEIGHT : 0; // Handle case where D is undefined
      const totalWidth = DATE_LABEL_WIDTH + gridWidth + DATE_LABEL_WIDTH + 2 * PADDING;
      const totalHeight = CONTEST_LABEL_HEIGHT + HEADER_HEIGHT + GRID_GAP + gridHeight + CONTEST_LABEL_HEIGHT + 2 * PADDING;

      // Adjust SVG size even if input is invalid (show minimal headers/labels)
      const initialWidth = DATE_LABEL_WIDTH + 26 * CELL_WIDTH + DATE_LABEL_WIDTH + 2 * PADDING;
      const initialHeight = CONTEST_LABEL_HEIGHT + HEADER_HEIGHT + GRID_GAP + CONTEST_LABEL_HEIGHT + 2 * PADDING; // Height without grid, but with gap
      svg.setAttribute("viewBox", `0 0 ${initialWidth} ${initialHeight}`);
      svg.setAttribute("width", initialWidth);
      svg.setAttribute("height", initialHeight);

      // Draw top contest number headers (1-26)
      for (let i = 0; i < 26; i++) {
        const x = PADDING + DATE_LABEL_WIDTH + i * CELL_WIDTH;
        const y = PADDING;
        const text = createText(x + CELL_WIDTH / 2, y + CONTEST_LABEL_HEIGHT / 2, i + 1, 8);
        svg.appendChild(text);
      }

      if (!D || !c || !s) {
        // Draw bottom contest number headers even without data
        for (let i = 0; i < 26; i++) {
          const x = PADDING + DATE_LABEL_WIDTH + i * CELL_WIDTH;
          const y = PADDING + CONTEST_LABEL_HEIGHT + HEADER_HEIGHT + GRID_GAP;
          const text = createText(x + CELL_WIDTH / 2, y + CONTEST_LABEL_HEIGHT / 2, i + 1, 8);
          svg.appendChild(text);
        }
        // Draw 'c' labels even without data
        const cLabelY = PADDING + CONTEST_LABEL_HEIGHT + HEADER_HEIGHT / 2;
        const leftCLabelX = PADDING + DATE_LABEL_WIDTH / 2;
        const leftCText = createText(leftCLabelX, cLabelY, "c", 8);
        svg.appendChild(leftCText);
        const rightCLabelX = PADDING + DATE_LABEL_WIDTH + gridWidth + DATE_LABEL_WIDTH / 2;
        const rightCText = createText(rightCLabelX, cLabelY, "c", 8);
        svg.appendChild(rightCText);
        return; // Cannot visualize full grid without valid input
      }

      // Recalculate total dimensions with valid D
      const validTotalHeight = CONTEST_LABEL_HEIGHT + HEADER_HEIGHT + GRID_GAP + D * CELL_HEIGHT + CONTEST_LABEL_HEIGHT + 2 * PADDING;
      svg.setAttribute("viewBox", `0 0 ${totalWidth} ${validTotalHeight}`);
      svg.setAttribute("width", totalWidth); // Adjust width
      svg.setAttribute("height", validTotalHeight); // Adjust height

      // Draw c_i headers
      for (let i = 0; i < 26; i++) {
        const x = PADDING + DATE_LABEL_WIDTH + i * CELL_WIDTH;
        const y = PADDING + CONTEST_LABEL_HEIGHT; // Shift down
        const color = getColor(c[i], MAX_C);
        const rect = createRect(x, y, CELL_WIDTH, HEADER_HEIGHT, color); // Use HEADER_HEIGHT
        svg.appendChild(rect);
        const text = createText(x + CELL_WIDTH / 2, y + HEADER_HEIGHT / 2, c[i]); // Center in HEADER_HEIGHT
        svg.appendChild(text);
      }

      // Draw s_{d,i} grid and date labels (left and right)
      const gridStartY = PADDING + CONTEST_LABEL_HEIGHT + HEADER_HEIGHT + GRID_GAP;
      for (let d = 0; d < D; d++) {
        const currentY = gridStartY + d * CELL_HEIGHT;

        // Draw left date label (1-D)
        const leftDateLabelX = PADDING + DATE_LABEL_WIDTH / 2;
        const dateLabelY = currentY + CELL_HEIGHT / 2;
        const leftDateText = createText(leftDateLabelX, dateLabelY, d + 1, 8);
        svg.appendChild(leftDateText);

        // Draw cells for the day
        for (let i = 0; i < 26; i++) {
          const x = PADDING + DATE_LABEL_WIDTH + i * CELL_WIDTH; // Shift right
          const y = currentY;
          const color = getColor(s[d][i], MAX_S);
          const rect = createRect(x, y, CELL_WIDTH, CELL_HEIGHT, color);
          rect.setAttribute("id", `cell-${d}-${i}`); // ID for highlighting
          svg.appendChild(rect);
          const text = createText(x + CELL_WIDTH / 2, y + CELL_HEIGHT / 2, s[d][i]);
          svg.appendChild(text);
        }

        // Draw right date label (1-D)
        const rightDateLabelX = PADDING + DATE_LABEL_WIDTH + gridWidth + DATE_LABEL_WIDTH / 2;
        const rightDateText = createText(rightDateLabelX, dateLabelY, d + 1, 8);
        svg.appendChild(rightDateText);
      }

      // Draw bottom contest number headers (1-26)
      const bottomLabelY = gridStartY + D * CELL_HEIGHT;
      for (let i = 0; i < 26; i++) {
        const x = PADDING + DATE_LABEL_WIDTH + i * CELL_WIDTH;
        const y = bottomLabelY;
        const text = createText(x + CELL_WIDTH / 2, y + CONTEST_LABEL_HEIGHT / 2, i + 1, 8);
        svg.appendChild(text);
      }

      // --- Add 'c' labels for the c_i row ---
      const cLabelY = PADDING + CONTEST_LABEL_HEIGHT + HEADER_HEIGHT / 2; // Vertical center of c_i row
      // Left 'c'
      const leftCLabelX = PADDING + DATE_LABEL_WIDTH / 2;
      const leftCText = createText(leftCLabelX, cLabelY, "c", 8);
      svg.appendChild(leftCText);
      // Right 'c'
      const rightCLabelX = PADDING + DATE_LABEL_WIDTH + gridWidth + DATE_LABEL_WIDTH / 2;
      const rightCText = createText(rightCLabelX, cLabelY, "c", 8);
      svg.appendChild(rightCText);
      // --- End of adding 'c' labels ---

      // Highlight selected contests if output is valid
      if (out && out.length === D) {
        for (let d = 0; d < D; d++) {
          const contestTypeIndex = out[d] - 1;
          if (contestTypeIndex >= 0 && contestTypeIndex < 26) {
            const rect = svg.getElementById(`cell-${d}-${contestTypeIndex}`);
            if (rect) {
              rect.classList.add("highlight"); // Use CSS class for highlighting
            }
          }
        }
      }
    }

    function updateVisualization() {
      const inputText = document.getElementById("input").value;
      const outputText = document.getElementById("output").value;
      const scoreElement = document.getElementById("score");

      const inputData = parseInput(inputText);

      let D = 0;
      let c = null;
      let s = null;
      let out = null;
      let score = 0;

      if (inputData) {
        D = inputData.D;
        c = inputData.c;
        s = inputData.s;
        out = parseOutput(outputText, D); // Parse output only if input is valid

        if (out) {
          score = calculateScore(D, c, s, out);
        } else {
          score = calculateScore(D, c, s, []); // Calculate score with empty output if output is invalid (will likely be low)
          // console.log("Output is invalid or does not match D."); // デバッグ用
        }
      } else {
        // console.log("Input is invalid."); // デバッグ用
        // Keep D=0, score=0, visualize will handle empty state
      }

      scoreElement.textContent = `Score = ${score.toLocaleString()}`;
      visualize(D, c, s, out); // Pass potentially null 'out'
    }

    // --- Seed 番号に基づいて入力ファイルを読み込む関数 ---
    async function loadInputBySeed() {
      const seedValue = document.getElementById("seed").value;
      const inputTextArea = document.getElementById("input");
      const scoreElement = document.getElementById("score"); // スコア表示もリセットするため

      if (seedValue === "" || isNaN(seedValue) || seedValue < 0) {
        // 無効な Seed の場合、Input欄をエラーメッセージで上書き
        inputTextArea.value = "無効な Seed 番号です。";
        scoreElement.textContent = "Score = 0";
        visualize(0, null, null, null); // ビジュアライザをクリア
        return;
      }

      const seedInt = parseInt(seedValue, 10);
      const fileName = String(seedInt).padStart(4, '0'); // 4桁ゼロ埋め
      const filePath = `in/${fileName}.txt`; // Visualizer.htmlからの相対パス (環境に応じて '../in/' などに変更)

      try {
        const response = await fetch(filePath);
        if (response.ok) {
          const text = await response.text();
          inputTextArea.value = text; // ファイル内容でInput欄を上書き
          updateVisualization(); // 読み込んだ入力でビジュアライザを更新
        } else {
          // ファイルが見つからない場合、Input欄をエラーメッセージで上書き
          inputTextArea.value = `Error: ファイル ${filePath} が見つかりません (${response.status} ${response.statusText})。\nWebサーバー経由でアクセスしていますか？`;
          scoreElement.textContent = "Score = 0";
          visualize(0, null, null, null); // ビジュアライザをクリア
        }
      } catch (error) {
        console.error("File fetch error:", error);
        // fetch自体に失敗した場合も、Input欄をエラーメッセージで上書き
        inputTextArea.value = `Error: ファイル ${filePath} の読み込みに失敗しました。\n${error}\nWebサーバー経由でアクセスしていますか？`;
        scoreElement.textContent = "Score = 0";
        visualize(0, null, null, null); // ビジュアライザをクリア
      }
    }
    // --- ここまで ---

    // Initial load with default seed (e.g., 0)
    loadInputBySeed(); // ページ読み込み時に Seed 0 のファイルを読み込む試み

  </script>

</body>

</html>